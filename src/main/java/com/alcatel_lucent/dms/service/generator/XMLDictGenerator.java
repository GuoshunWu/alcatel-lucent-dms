package com.alcatel_lucent.dms.service.generator;

import com.alcatel_lucent.dms.BusinessException;
import com.alcatel_lucent.dms.SystemError;
import com.alcatel_lucent.dms.model.*;
import com.alcatel_lucent.dms.service.DaoService;
import com.alcatel_lucent.dms.util.Util;
import org.apache.commons.collections.*;
import org.apache.commons.lang3.ArrayUtils;
import org.apache.log4j.Logger;
import org.dom4j.Document;
import org.dom4j.DocumentHelper;
import org.dom4j.Element;
import org.dom4j.io.OutputFormat;
import org.dom4j.io.XMLWriter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.io.*;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;

import static org.apache.commons.lang.StringUtils.join;

@Component("XmlDictGenerator")
public class XMLDictGenerator implements DictionaryGenerator {

    private static Logger log = Logger.getLogger(XMLDictGenerator.class);

    @Autowired
    private DaoService dao;

    @Override
    public void generateDict(File targetDir, Long dictId) throws BusinessException {
        Dictionary dict = (Dictionary) dao.retrieve(Dictionary.class, dictId);

    }

    public void generateDict(File targetDir, Dictionary dict) throws BusinessException {
        XMLWriter writer = null;
        log.info("");
        try {
            File file = new File(targetDir, dict.getName() + ".xdct");
            if (!file.exists()) {
                if (!file.getParentFile().exists()) {
                    file.getParentFile().mkdirs();
                }
                file.createNewFile();
            }
            writer = new XMLWriter(new FileOutputStream(file), OutputFormat.createPrettyPrint());
            writer.write(generateDocument(dict));
        } catch (IOException e) {
            throw new SystemError(e.getMessage());
        } finally {
            try {
                writer.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    public Document generateDocument(Dictionary dict) {

        Document doc = DocumentHelper.createDocument();
        doc.setXMLEncoding("UTF-8");
        doc.addDocType("DICTIONARY", "", "XMLDICT.dtd");

        final Element xmlDict = doc.addElement("DICTIONARY");
        if (null == dict) return doc;
        doc.addComment("\n# Generated by DMS.\n" + "# Labels: " + dict.getLabelNum() + "\n");

        Map<String, String> attributes = Util.string2Map(dict.getAnnotation1());

        xmlDict.addAttribute("name", attributes.get("name"));
        xmlDict.addAttribute("type", attributes.get("type"));
        xmlDict.addAttribute("appli", attributes.get("appli"));
        xmlDict.addAttribute("separator", attributes.get("separator"));

        CollectionUtils.forAllDo(dict.getDictLanguages(), new Closure() {
            @Override
            public void execute(Object input) {
                DictionaryLanguage language = (DictionaryLanguage) input;
                Element xmlLanguage = xmlDict.addElement("LANGUAGE");
                xmlLanguage.addAttribute("id", language.getLanguageCode());
                Map<String, String> langAttrs = Util.string2Map(language.getAnnotation1());
                xmlLanguage.addAttribute("is_reference", langAttrs.get("is_reference"));
                xmlLanguage.addAttribute("is_context", langAttrs.get("is_context"));
            }
        });

        CollectionUtils.forAllDo(dict.getLabels(), new Closure() {
            @Override
            public void execute(Object input) {
                Label label = (Label) input;

                final Element xmlKey = xmlDict.addElement("KEY");
                xmlKey.addAttribute("name", label.getKey());

                Map<String, String> map = Util.string2Map(label.getAnnotation1());

                xmlKey.addAttribute("columns", map.get("columns"));
                xmlKey.addAttribute("lines", map.get("lines"));
                xmlKey.addAttribute("message_category", map.get("message_category"));
                xmlKey.addAttribute("gui_object", map.get("gui_object"));
                xmlKey.addAttribute("state", map.get("state"));

                Closure commentClosure = new Closure() {
                    @Override
                    public void execute(Object input) {
                        LabelTranslation lt = (LabelTranslation) input;
                        Element comment = xmlKey.addElement("COMMENT");
                        comment.setText(lt.getValueFromField("comment", LabelTranslation.ANNOTATION1));
                        comment.addAttribute("language", lt.getLanguageCode());
                    }
                };

                Closure helpClosure = new Closure() {
                    @Override
                    public void execute(Object input) {
                        LabelTranslation lt = (LabelTranslation) input;
                        Element help = xmlKey.addElement("HELP");
                        help.addAttribute("follow_up", lt.getValueFromField("follow_up", LabelTranslation.ANNOTATION1));
                        help.addAttribute("language", lt.getLanguageCode());
                        help.setText(lt.getValueFromField("help", LabelTranslation.ANNOTATION1));
                    }
                };

                Closure translationClosure = new Closure() {
                    @Override
                    public void execute(Object input) {
                        LabelTranslation lt = (LabelTranslation) input;
                        Element trans = xmlKey.addElement("TRANSLATION");
                        trans.addAttribute("follow_up", lt.getValueFromField("follow_up", LabelTranslation.ANNOTATION1));
                        trans.addAttribute("language", lt.getLanguageCode());
                        trans.setText(lt.getOrigTranslation());
                    }
                };

                Collection<LabelTranslation> labelTranslations = label.getOrigTranslations();

//              write all the comment
                Element comment = xmlKey.addElement("COMMENT");
                comment.addAttribute("language", "GAE");
                comment.setText(map.get("comment"));
                CollectionUtils.forAllDo(labelTranslations, commentClosure);


                Element context = xmlKey.addElement("CONTEXT");
                context.addAttribute("language", "GAE");
                context.setText(map.get("context"));
//              TODO: implement multiple context

                Element help = xmlKey.addElement("HELP");
                help.addAttribute("language", "GAE");
                help.addAttribute("follow_up", map.get("follow_up"));
                help.setText(map.get("help"));
                CollectionUtils.forAllDo(labelTranslations, helpClosure);

                String[] sts = label.getValueFromField("STATIC_TOKEN", Label.ANNOTATION2).split(";");
                for (String st : sts) {
                    Element staticToken = xmlKey.addElement("STATIC_TOKEN");
                    staticToken.setText(st);
                }

                Element translation = xmlKey.addElement("TRANSLATION");
                translation.addAttribute("language", "GAE");
                translation.addAttribute("follow_up", map.get("follow_up"));
                translation.setText(label.getValueFromField("help", Label.ANNOTATION1));
                CollectionUtils.forAllDo(labelTranslations, translationClosure);

                IterableMap params = label.getParams();
                MapIterator it = params.mapIterator();

                while (it.hasNext()) {
                    Object key = it.next();
                    Object value = it.getValue();
                    Element param = xmlKey.addElement("PARAM");
                    param.addAttribute("name", (String) key);
                    param.addAttribute("value", (String) value);
                }

            }
        });

        return doc;
    }
}
